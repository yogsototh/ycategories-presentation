<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>Category Theory for Programming</title>

	<!-- Required stylesheet -->
	<link rel="stylesheet" href="core/deck.core.css">

	<!-- Extension CSS files go here. Remove or add as needed. -->
	<link rel="stylesheet" href="extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="extensions/status/deck.status.css">
	<link rel="stylesheet" href="extensions/hash/deck.hash.css">
    <link rel="stylesheet" href="extensions/scale/deck.scale.css">

	<!-- Transition theme. More available in /themes/transition/ or create your own. -->

    <!-- <link rel="stylesheet" href="themes/transition/fade.css"> -->
	<!-- Style theme. More available in /themes/style/ or create your own. -->
    <!-- <link rel="stylesheet" href="themes/style/web-2.0.css"> -->
    <link rel="stylesheet" href="themes/style/y/main.css" />
    <link rel="stylesheet" href="themes/style/y/solarized.css" />
	<!-- Required Modernizr file -->
	<script src="modernizr.custom.js"></script>
</head>
<body class="deck-container">

<div style="display:none">
\(\newcommand{\F}{\mathbf{F}}\)
\(\newcommand{\E}{\mathbf{E}}\)
\(\newcommand{\C}{\mathcal{C}}\)
\(\newcommand{\D}{\mathcal{D}}\)
\(\newcommand{\id}{\mathrm{id}}\)
\(\newcommand{\ob}[1]{\mathrm{ob}(#1)}\)
\(\newcommand{\hom}[1]{\mathrm{hom}(#1)}\)
\(\newcommand{\Set}{\mathbf{Set}}\)
\(\newcommand{\Mon}{\mathbf{Mon}}\)
\(\newcommand{\Vec}{\mathbf{Vec}}\)
\(\newcommand{\Grp}{\mathbf{Grp}}\)
\(\newcommand{\Rng}{\mathbf{Rng}}\)
\(\newcommand{\ML}{\mathbf{ML}}\)
\(\newcommand{\Hask}{\mathbf{Hask}}\)
\(\newcommand{\Cat}{\mathbf{Cat}}\)
\(\newcommand{\fmap}{\mathtt{fmap}}\)
</div>

<!-- Begin slides. Just make elements with a class of slide. -->

<section class="slide">
<h1>Category Theory <span class="and"><span class="and">&amp;</span></span> Programming
    <div><author style="font-size: .4em"><em class="base01">by</em> Yann Esposito
        <div style="font-size:.5em">
            <twitter>
                <a href="http://twitter.com/yogsototh">@yogsototh</a>,
            </twitter>
            <googleplus>
                <a href="https://plus.google.com/117858550730178181663">+yogsototh</a>
            </googleplus>
        </div>
    </author></div>
    <div class="base01" style="font-size: .25em; font-weight: 400; font-variant:italic">
        HTML presentation: use arrows, space to navigate.
    </div>
</h1>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li><span class="yellow">Why?
<ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: 0 0 0 1em">
    <li>General overview</li>
    <li>Math <span class="and"><span class="and">&amp;</span></span> Abstraction</li>
    <li>Programming <span class="and"><span class="and">&amp;</span></span> Abstraction</li>
    <li>Categories <span class="and"><span class="and">&amp;</span></span> Abstraction</li>
</ul>
    </li>
    <li>What?</li>
    <li>How?</li>
</ul>
</section>
<section class="slide">
<h2 id="category-theory-high-level">Category Theory: High level</h2>
<ul>
<li>Central position in contemporary mathematics/computer science/physics.</li>
<li>General mathematical theory of structures and of systems of structures.</li>
<li>Still evolving, developing, expanding and multiplying.</li>
<li>At minimum, powerful language, or conceptual framework.</li>
<li>Object of philosophical study and a potentially powerful formal tool.</li>
<li>Alternative to set theory as a foundation for mathematics.</li>
<li>Raises many issues about mathematical ontology and epistemology.</li>
<li>It thus affords philosophers and logicians much to use and reflect upon.</li>
</ul>
</section>
<section class="slide">
<img src="categories/img/head_explode.jpg" alt="head explode" style="width: 80%"/>
</section>
<section class="slide">
<h2 id="category-theory-for-programming">Category Theory for programming?</h2>
<img class="right" src="categories/img/buddha.png" alt="buddha"/>
<ul>
<li>Ability to see problem differently</li>
<li>Make generalisation easier</li>
<li>Help code organisation</li>
<li>Reduce bugs by clarifying concepts</li>
</ul>
<p>Example In Haskell:</p>
<ul>
<li>Functors</li>
<li>Monads</li>
<li><code>fold</code> generalisation</li>
<li>Applicative Functors, Arrows, ...</li>
</ul>
</section>
<section class="slide">
<h2>Abstraction</h2>
<p>A common concept you see in multiple instances.</p>
<div>
    <p>Numbers: 1,2,3,...  <em class="small">3400 BC, real numbers 760 BC</em></p>
    <figure class="left">
        <img src="categories/img/tally-count.png" style="height:5em" alt="Aboriginal Tally System"/>
        <figcaption>Aboriginal Tally System</figcaption>
    </figure>
    <div>
        <div class="left" style="margin: 2em 1em">amelioration ⇒</div>
        <figure class="left">
            <img src="categories/img/first-real-numbers.png" style="height:5em" alt="Mesopotamian Numbers"/>
            <figcaption>Mesopotamian base 60 system</figcaption>
        </figure>
    </div>
    <div class="flush"></div>
    <div>
        Operators: <b>=, &lt;, &gt;, +, ×, ...</b>
    </div>
</section>
<section class="slide">
<h2>Generalization</h2>
<div class="right">
<img src="categories/img/egyptian-hieroglyphics.jpg" alt="Egyptian Fractions"/>
<img src="categories/img/negative-numbers.jpg" alt="Negative Numbers (Chinese)"/>
</div>
<ul><li> Weight/Distance/Time ⇒ <em>Rational</em> \(\frac{p}{q}\)
</li><li> Debts ⇒ <em>Negative</em> \(..., -2, -1, ? , 1, 2, ...\)
</li><li> Geometry ⇒ <em>Irrational<sup style="vertical-align:middle">*</sup></em>
</li><li> Algebra ⇒ <em>Complex</em>
</li><li> \(0\) ⇒ "Nothing" become a number
</li></ul>
<p><span class="and" style="visibility:hidden"><span class="and">&amp;</span></span> More <strong>things</strong> can be understood as numbers<br/>
<span class="and"><span class="and">&amp;</span></span> More <strong>ways</strong> to manipulate them.</p>
</section>
<section class="slide">
<h2>Numbers ⇒ Sets</h2>
<table>
<tr>
    <th>Numbers</th>
    <th>Set Theory (∞)/Abstract Algebra/Topology</th>
</tr>
<tr>
    <td>\(\mathbb{N}\): \((+,0)\)</td>
    <td>Semigroups</td>
</tr>
<tr>
    <td>\(\mathbb{Z}\): \((+,0,\times,1)\)</td>
    <td>Rings</td>
</tr>
<tr>
    <td>\(\mathbb{Q}\)</td>
    <td>Fields</td>
</tr>
<tr>
    <td>\(\mathbb{R}\)</td>
    <td>Complete Fields (<em class="base01">topology</em>)</td>
</tr>
<tr>
    <td>\(\mathbb{C}\)</td>
    <td>Algebræ</td>
</tr>
<tr><td></td><td>Modules,Vector Spaces, Monoids, ...</td></tr>
</table>
<p><span class="and" style="visibility:hidden"><span class="and">&amp;</span></span> More <strong>general</strong>: more things are sets.<br/>
    <span class="and"><span class="and">&amp;</span></span> More <strong>precise</strong>: clear distinction between concepts.</p>
</section>
<section class="slide">
<h2>Sets ⇒? <span class="yellow">Categories</span></h2>
<table>
<tr>
    <th>Numbers</th>
    <th>Sets</th>
    <th>Categories</th>
</tr>
<tr>
    <td>\(\mathbb{N}\): \((+,0)\)</td>
    <td>Semigroups</td>
    <td></td>
</tr>
<tr>
    <td>\(\mathbb{Z}\): \((+,0,\times,1)\)</td>
    <td>Rings</td>
    <td></td>
</tr>
<tr>
    <td>\(\mathbb{Q}\)</td>
    <td>Fields</td>
    <td></td>
</tr>
<tr>
    <td>\(\mathbb{R}\)</td>
    <td>Complete Fields (<em class="base01">topology</em>)</td>
    <td></td>
</tr>
<tr>
    <td>\(\mathbb{C}\)</td>
    <td>Algebræ</td>
    <td></td>
</tr>
<tr><td></td><td>Modules,Vector Spaces, Monoids, ...</td><td></td></tr>
</table>
<p><span class="and" style="visibility:hidden"><span class="and">&amp;</span></span> More <strong>general</strong>: more things are <span class="yellow">categories</span>.<br/>
<span class="and"><span class="and">&amp;</span></span> More <strong>abstract</strong>: generalization for free; replace = by <span class="yellow">≅</span>.<br/>
<span class="and"><span class="and">&amp;</span></span> Homogeneous <strong>vocabulary</strong>.
</p>
</section>
<section class="slide">
<h2>Category Theory</h2>
<p>Categories package entire mathematical theories.</p>
<ul>
<li>Topology</li>
<li>Quantum Physics</li>
<li>Logic</li>
<li><b>Programming</b></li>
</ul>
<p><span class="and" style="visibility:hidden"><span class="and">&amp;</span></span> More <strong>general</strong>: more things are Categories.<br/>
    <span class="and"><span class="and">&amp;</span></span> More <strong>precise</strong>: better distinction between concepts.</p>
<p>Young field: <b>1942–45</b>, Samuel Eilenberg <span class="and"><span class="and">&amp;</span></span> Saunders Mac Lane
</section>
<section class="slide">
<h2>Programming <span class="and"><span class="and">&amp;</span></span> Abstraction</h2>

<h3>Impure programming</h3>
<ul>
    <li>Encouraged by imperative paradigms.
    </li><li>Actions <span class="and"><span class="and">&amp;</span></span> mutable objects.
    </li><li>Time is <em>very</em> important: ex. linked list push
    </li><li>Synchronizing things is a challenge.
    </li>
</ul>
<p>Natural Abstractions: pointers, variables, loop, Objects, Classes...</p>
<p>Representation: a data structure changing other time.</p>
</section>
<section class="slide">
<h2>Untyped Pure Programming</h2>

<ul><li> Time is irrelevant by default.
</li><li> Mostly static constructions like pipes.
</li><li> All pipes can be plugged ⇒ all error at runtime
     <ul><li> (+ ("foo" 27) 32)
    </li><li> Y = λf.(λx.f (x x)) (λx.f (x x))
    </li><li> Y g = g (Y g)
    </li></ul>
</li></ul>

<p>Natural abstraction: higher level functions <span class="and"><span class="and">&amp;</span></span> equations</p>
</section>
<section class="slide">
<h2>Typed Pure Programming</h2>
<ul><li>Add shapes to pipes:
     <ul><li> <code class="red">4 + ["foo",27]</code> forbidden
    </li><li> <code class="red">["foo",27]</code> forbidden
    </li></ul>
</li><li>Polymorphic (elastic) shapes:
    <ul><li>  <code>data Maybe a = Just a | Nothing</code>
    </li><li> <code>[Just 32,Nothing,Just 12] :: [Maybe Integer]</code>
    </li></ul>
</li></ul>
<p>Natural abstraction: Polymorphic higher level functions.</p>
</section>
<section class="slide">
<h2>Polymorphism: <code>mappend (<>)</code></h2>

<pre class="small haskell"><code>   "abcdef" <span class="red"><></span>  "ABCDEF"   = "abcdefABCDEF"  -- String
("ab","xy") <span class="red"><></span> ("AB","XY") = ("abAB","xyXY") -- (String,String)

3 <span class="red"><></span> 4 ⇒ ERROR which law? + or * -- Int

-- Use a type to remove ambiguity
type Sum = Sum {getSum :: a} -- Just a named box
-- Monoid (Int,+,0)
(<>+) = getSum (Sum x <span class="red"><></span> Sum y)
3 <>+ 4 = 7

-- Monoid (Int,*,0)
type Product = Product {getProduct :: a} -- Just a named box
(<>*) = getProduct (Product x <span class="red"><></span> Product y)
3 <>* 4 = 12</code></pre>

<p>Note: with Monoids (M,⊙,e); <code>foldl ⊙ e ms = foldr ⊙ e ms</code></p>
</section>
<section class="slide">
<h2>Polymorphism: <code>(>>=)</code></h2>

<p>Example: <span class="red"><code>(>>=)</code></span> with <code>[a]</code> and <code>Maybe a</code></p>
<pre class="small haskell"><code>data Maybe a = Just a | Nothing</code></pre>

<pre class="small haskell"><code>-- Maybe Int >>= Int -> Maybe (Int -> Int) >>= (Int -> Int) -> Maybe Int
(Just 2) <span class="red">&gt;&gt;=</span> \x -> (Just (\z->z*z)) <span class="red">&gt;&gt;=</span> \f -> Just (f x) = Just 4
 Nothing <span class="red">&gt;&gt;=</span> \x -> (Just (\z->z*z)) <span class="red">&gt;&gt;=</span> \f -> Just (f x) = Nothing

-- [Int] >>= Int -> [Int -> Int] >>= (Int -> Int) -> [Int]
[1,2] <span class="red">&gt;&gt;=</span> \x -> [(+10),(+20)] <span class="red">&gt;&gt;=</span> \f -> [f x] = [11,21,12,22]
   [] <span class="red">&gt;&gt;=</span> \x -> [(+10),(+20)] <span class="red">&gt;&gt;=</span> \f -> [f x] = []</code></pre>
</section>
<section class="slide">
<h2>Programming Paradigms</h2>
<table>
    <tr><td>Impure</td><td>Choose the data structure, find an algorithm.</td></tr>
    <tr><td>Untyped Pure</td><td>Choose the data structure, find an equation.</td></tr>
    <tr><td>Typed Pure</td><td>Choose the Types and their laws, find the right operator</td></tr>
</table>

</section>
<section class="slide">
<h2>Type Theory ⇒ Categories</h2>

<ul>
    <li>Type theory helped to remove paradoxes in Set Theory.</li>
    <li>Prevent relations between different kind of objects.</li>
    <li>Used in computer science</li>
</ul>

<ul>
    <li>typed λ-calculus ⇒ cartesian closed categories</li>
    <li>untyped λ-calculus ⇒ C-monoids (subclass of categories)</li>
    <li>Martin-Löf type theories ⇒ locally cartesian closed categories</li>
</ul>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight: bold">
    <li>Why?</li>
    <li> <span class="yellow">What?</span>
<ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: 0 0 0 1em">
    <li>Category</li>
    <li>Intuition</li>
    <li>Examples</li>
    <li>Functor</li>
    <li>Examples</li>
</ul>
    </li>
    <li>How?</li>
</ul>
</section>
<section class="slide">
<h2>Category</h2>

<p>A way of representing <strong><em>things</em></strong> and <strong><em>ways to go between things</em></strong>.</p>

<p> A Category \(\mathcal{C}\) is defined by:</p>
<ul>
    <li> <em>Objects (\(\ob{C}\))</em>,</li>
    <li> <em>Morphisms (\(\hom{C}\))</em>,</li>
    <li> a <em>Composition law (∘)</em></li>
    <li> obeying some <em>Properties</em>.</li>
</ul>
</section>
<section class="slide">
<h2>Category: Objects</h2>

<img src="categories/img/mp/objects.png" alt="objects" />

<p>\(\ob{\mathcal{C}}\) is a collection</p>
</section>
<section class="slide">
<h2>Category: Morphisms</h2>

<img src="categories/img/mp/morphisms.png" alt="morphisms"/>

<p>\(\hom{A,B}\) is a collection</p>
</section>
<section class="slide">
<h2>Category: Composition</h2>
<p>Composition (∘): \(f:A→B, g:B→C\)
    $$g∘f:A\rightarrow C$$
</p>
<img src="categories/img/mp/composition.png" alt="composition"/>
</section>
<section class="slide">
<h2>Category laws: neutral element</h2>
<p>for each object \(X\), there is an \(\id_X\), s.t. for all \(f:A→B\):</p>
<img src="categories/img/mp/identity.png" alt="identity"/>
</section>
<section class="slide">
<h2>Category laws: Associativity</h2>
<p> Composition is associative:</p>
<img src="categories/img/mp/associativecomposition.png" alt="associative composition"/>
</section>
<section class="slide">
<h2>Commutative diagrams</h2>

<p>Two path with the same source and destination are equal.</p>
<figure class="left" style="max-width: 40%;margin-left: 10%;">
    <img
      src="categories/img/mp/commutative-diagram-assoc.png"
      alt="Commutative Diagram (Associativity)"/>
    <figcaption>
    \((h∘g)∘f = h∘(g∘f) \)
    </figcaption>
</figure>
<figure class="right" style="max-width:31%;margin-right: 10%;">
    <img
      src="categories/img/mp/commutative-diagram-id.png"
      alt="Commutative Diagram (Identity law)"/>
    <figcaption>
    \(id_B∘f = f = f∘id_A \)
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Can this be a category?</h2>
<p>\(\ob{\C},\hom{\C}\) fixed, is there a valid ∘?</p>
<figure class="left">
    <img src="categories/img/mp/cat-example1.png" alt="Category example 1"/>
    <figcaption class="slide">
        <span class="green">YES</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="categories/img/mp/cat-example2.png" alt="Category example 2"/>
    <figcaption class="slide">
        no candidate for \(g∘f\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="categories/img/mp/cat-example3.png" alt="Category example 3"/>
    <figcaption class="slide">
    <span class="green">YES</span>
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Can this be a category?</h2>
<figure class="left">
    <img src="categories/img/mp/cat-example4.png" alt="Category example 4"/>
    <figcaption class="slide">
        no candidate for \(f:C→B\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="right" style="min-width: 59%">
    <img src="categories/img/mp/cat-example5.png" alt="Category example 5"/>
    <figcaption class="slide">
    \((h∘g)∘f=\id_B∘f=f\)<br/>
    \(h∘(g∘f)=h∘\id_A=h\)<br/>
    but \(h≠f\)<br/>
    <span class="red">NO</span>
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Category \(\Set\)</h2>

<ul>
    <li> \(\ob{\Set}\) are sets</li>
    <li> \(\hom{\Set}\) are functions</li>
    <li> ∘ is functions composition </li>
</ul>

<ul class="slide">
    <li>\(\ob{\Set}\) is a proper class ; not a set</li>
    <li>\(\hom{E,F}\) is a set</li>
    <li>\(\Set\) is a <em>locally small category</em></li>
</ul>
</section>
<section class="slide">
<h2>Categories Everywhere?</h2>

<ul>
    <li>\(\Mon\): (monoids, monoid morphisms,∘)</li>
    <li>\(\Vec\): (Vectorial spaces, linear functions,∘)</li>
    <li>\(\Grp\): (groups, group morphisms,∘)</li>
    <li>\(\Rng\): (rings, ring morphisms,∘)</li>
    <li>Any deductive system <i>T</i>: (formulæ, proofs, proof concatenation)</li>
    <li>\( \Hask\): (Haskell types, functions, <code>(.)</code> )</li>
    <li>...</li>
</ul>
</section>
<section class="slide">
<h2>Smaller Examples</h2>

<h3>Strings</h3>
<img class="right" style="max-width:17%" src="categories/img/mp/strings.png" alt="Monoids are one object categories"/>
<ul>
    <li> \(\ob{Str}\) is a singleton </li>
    <li> \(\hom{Str}\) each string </li>
    <li> ∘ is concatenation <code>(++)</code> </li>
</ul>
<ul>
    <li> <code>"" ++ u = u = u ++ ""</code> </li>
    <li> <code>(u ++ v) ++ w = u ++ (v ++ w)</code> </li>
</ul>
</section>
<section class="slide">
<h2>Finite Example?</h2>

<h3>Graph</h3>
<figure class="right" style="max-width:40%" >
<img src="categories/img/mp/graph-category.png" alt="Each graph is a category"/>
</figure>
<ul>
    <li> \(\ob{G}\) are vertices</li>
    <li> \(\hom{G}\) each path</li>
    <li> ∘ is path concatenation</li>
</ul>
<ul><li>\(\ob{G}=\{X,Y,Z\}\),
    </li><li>\(\hom{G}=\{ε,α,β,γ,αβ,βγ,...\}\)<br/>
    \(\phantom{\hom{G}}=(β?γ)?(αβγ)^*(αβ?)?\),
    </li><li>\(αβ∘γ=αβγ\)
</li></ul>
</section>
<section class="slide">
<h2>Degenerated Categories</h2>

<img class="right" style="max-width:17%" src="categories/img/mp/monoid.png" alt="Monoids are one object categories"/>
<h3>Monoids</h3>
<p>each Monoid \((M,e,⊙): \ob{M}=\{∙\},\hom{M}=M,\circ = ⊙\)</p>
<p>one object</p>
<p>Examples: <code>(Integer,0,+)</code>, <code>(Integer,1,*)</code>, <code>(Strings,"",++)</code>, <code>(Lists,[],++)</code>, ...
</section>
<section class="slide">
<h2>Number construction</h2>

<h3>Each Numbers as a whole category</h3>
<img src="categories/img/mp/numbers.png" alt="Each number as a category"/>
</section>
<section class="slide">
<h2>Degenerated Categories: Preorders</h2>

<h3>Preorders</h3>
<p>each preorder \((P,≤): \ob{P}={P},\hom{x,y}=\{{x≤y}\} ⇔ x≤y,f_{y,z} \circ f_{x,y} = f_{x,z} \)</p>
<em>At most one morphism between two objects.</em>
<img src="categories/img/mp/preorder.png" alt="preorder category"/>
</section>
<section class="slide">
<h2>Degenerated Categories</h2>

<img class="right" src="categories/img/mp/set.png" alt="Any set can be a category"/>
<h3>Any Set</h3>
<p>Any set \(E: \ob{E}=E, \hom{x,y}=\{x\} ⇔  x=y \)</p>
<p><em>Only identities ; not so interesting</em></p>
</section>
<section class="slide">
<h2>Categorical Property</h2>

<p>Any property which can be expressed in term of category, objects, morphism and composition</p>

<ul><li> <em>isomorphism</em>: \(f:A→B\) s.t. ∃g:B→A, \(g∘f=id_A\) <span class="and">&amp;</span> \(f∘g=id_B\)
</li><li> <em>Initial</em>: \(Z\in\ob{C}\) s.t. \(∀Y∈\ob{C}, \#\hom{Z,Y}=1\)
</li><li> <em>Dual</em>: reverse direction of arrows of \(\C\)
</li><li> <em>Functor</em>: structure preserving mapping between categories
</li><li> ...
</li></ul>
</section>
<section class="slide">
<h2>Functor</h2>

<p> A functor is a mapping between two categories.
Let \(\C\) and \(\D\) be two categories.
A <em>functor</em> \(\F\) from \(\C\) to \(\D\):</p>
<ul>
    <li> Associate objects: \(A\in\ob{\C}\) to \(\F(A) \in\ob{\D}\) </li>
    <li> Associate morphisms: \(f:A\to B\) to \(\F(f) : \F(A) \to \F(B)\)
        such that
        <ul>
            <li>\( \F (\id_X) = \id_{\F(X)} \),</li>
            <li>\( \F (g \circ_\C f) = \F(g) \circ_\D \F(f) \)</li>
        </ul>
    </li>
</ul>
</section>
<section class="slide">
<h2>Functor Example (ob → ob)</h2>

<img src="categories/img/mp/functor.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Functor Example (hom → hom)</h2>

<img src="categories/img/mp/functor-morphism.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Functor Example</h2>

<img src="categories/img/mp/functor-morphism-color.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Endofunctors</h2>

<p>An <em>endofunctor</em> for \(\C\) is a functor \(F:\C→\C\).</p>
<img src="categories/img/mp/endofunctor.png" alt="Endofunctor"/>
</section>
<section class="slide">
<h2>Category of Categories</h2>

<p>Categories and functors form a category: \(\Cat\)</p>
<ul><li>\(\ob{\Cat}\) are categories
</li><li>\(\hom{\Cat}\) are functors
</li><li>∘ is functor composition
</li></ul>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li>Why?</li>
    <li>What?</li>
    <li><span class="yellow">How?
        <ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: -2em 0 0 1em">
            <li>\(\Hask\) category
            </li><li> Functors
            </li><li> Monads
            </li><li> Arrows
            </li><li> κατα-morphisms
            </li></ul>
    </li>
</ul>
</section>
<section class="slide">
<h2>Hask</h2>

<p>Category \(\Hask\):</p>

<img class="right" style="max-width:30%" src="categories/img/mp/hask.png" alt="Haskell Category Representation"/>

<ul><li>
\(\ob{\Hask} = \) Haskell types
</li><li>
\(\hom{\Hask} = \) Haskell functions
</li><li>
∘ = <code>(.)</code> Haskell function composition
</li></ul>

<p>Forget glitches because of <code>undefined</code>.</p>
</section>
<section class="slide">
<h2 id="haskell-kinds">Haskell Kinds</h2>
<p>In Haskell some types can take type variable. Typically: <code>[a]</code>.</p>
<pre><code>data Tree a = Node a [Tree a]
data CTree a b = CNode a [b]</code></pre>
<p>Types have <em>kind</em>; The kind is to type what type is to function. Kind are the &quot;type&quot; for some types (so meta).</p>
<pre><code>Int, Char :: *
[], Maybe, Tree :: * -&gt; *
CTree :: * -&gt; * -&gt; *
[Int], Maybe Char, Tree [Int] :: *</code></pre>
</section>
<section class="slide">
<h2 id="haskell-types">Haskell Types</h2>
<p>We can make function that can work for <em>all</em> type parameter. Such function can only work with the <em>topology</em> induced by the type. We know such function won't work <em>on</em> the elements.</p>
<p>Sometimes, the type determine a lot about the function:</p>
<pre class="haskell"><code>fst :: (a,b) -> a -- Only one choice
snd :: (a,b) -> b -- Only one choice
f :: a -> [a]     -- Many choices
-- Possibilities: f x=[], or [x], or [x,x] or [x,...,x]

? :: [a] -> [a] -- Many choices
-- can only duplicate/remove/reorder elements
-- for example: the type of addOne isn't [a] -> [a]
addOne l = map (+1) l</code></pre>


</section>
<section class="slide">
<h2>Haskell Functor vs \(\Hask\) Functor</h2>

<p>Functor for Haskell language is a type <code>F :: * -> *</code> which belong to the type class <code>Functor</code>.<br/>
It must implement <code>fmap :: (a -> b) -> (F a -> F b)</code>.

<p><span style="visibility:hidden"><span class="and">&amp;</span></span> <code>F</code>: \(\ob{\Hask}→\ob{\Hask}\)<br/> <span class="and">&amp;</span> <code>fmap</code>: \(\hom{\Hask}→\hom{\Hask}\)

<p>The couple <code>(F,fmap)</code> is a functor in the categorical sense for \(\Hask\) if for any <code>x :: F a</code>:</p>
<ul><li><code>fmap id x = x</code>
</li><li><code>fmap (f.g) x= (fmap f . fmap g) x</code>
</li></ul>
</section>
<section class="slide">
<h2>Haskell Functors Example: Maybe</h2>

<pre class="haskell"><code>data Maybe a = Just a | Nothing
instance Functor Maybe where
    fmap :: (a -> b) -> (Maybe a -> Maybe b)
    fmap f (Just a) = f a
    fmap f Nothing = Nothing

fmap (+1) (Just 1) == 2
fmap (+1) Nothing  == Nothing
fmap head (Just [1,2,3]) == Just 1</code></pre>
</section>
<section class="slide">
<h2>Haskell Functors Example: List</h2>

<pre class="haskell"><code>
instance Functor ([]) where
    fmap :: (a -> b) -> [a] -> [b]
    fmap = map

fmap (+1) [1,2,3]           == [2,3,4]
fmap (+1) []                == []
fmap head [[1,2,3],[4,5,6]] == [1,4]
</code></pre>
</section>
<section class="slide">
<h2>String like type</h2>

<pre class="haskell"><code>
data F a = Cons Char a | Nil
-- examples :
--  Cons 'c' 32 :: F Int
--  Cons 'c' (\x -> x*x) :: F (Int -> Int)
--  Cons 'c' (Cons 'a' (\x -> x*x)) :: F (F (Int -> Int))
--  Cons 'c' (Cons 'c' Nil) :: F (F (F))
-- note String is the fixed point of F: F(F(F(...)))
instance Functor F where
    fmap :: (a -> b) -> [a] -> [b]
    fmap f (Cons c x) = Cons c (f x)
    fmap f Nil = Nil

fmap (+1) (Cons 'c' 3)      == Cons 'c' 4
fmap (+1) Nil               == Nil
fmap head (Cons 'c' [1,2,3])== Cons 'c' 1
</code></pre>
</section>
<section class="slide">
<h2>Haskell Functor intuition</h2>

<p>Put normal function inside a container. Ex: list, trees...<p>

<img src="categories/img/mp/boxfunctor.png" alt="Haskell Functor as a box play"/>
</section>
<section class="slide">
<h2>Haskell Functor properties</h2>

<p>Haskell Functors are:</p>

<ul><li><em>endofunctors</em> ; \(F:\C→\C\) here \(\C = \Hask\),
</li><li>a couple <b>(Object,Morphism)</b> in \(\Hask\).
</li></ul>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor-objects.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor-morphisms.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2 id="non-haskell-hasks-functors">&quot;Non Haskell&quot; Hask's Functors</h2>
<p>A simple basic example is the \(id_\Hask\) functor. It simply cannot be expressed as a couple (<code>F</code>,<code>fmap</code>) where</p>
<ul>
<li><code>F::* -&gt; *</code></li>
<li><code>fmap :: (a -&gt; b) -&gt; (F a) -&gt; (F b)</code></li>
</ul>
<p>Another example:</p>
<ul>
<li>F(<code>T</code>)=<code>Int</code></li>
<li>F(<code>f</code>)=<code>\_-&gt;0</code></li>
</ul>
</section>
<section class="slide">
<h2 id="also-functor-inside-hask">Also Functor inside \(\Hask\)</h2>
<p><code>length</code> can be seen as a Functor from the category <code>[a]</code> to <code>Int</code>. More precisely:</p>
<ul class="left">
<li>\(\ob{\mathtt{[a]}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{[a]}}=\mathtt{[a]}\)</li>
<li>\(∘=\mathtt{(++)}\)</li>
</ul>
<p class="left" style="margin:2em 3em">⇒</p>
<ul class="left">
<li>\(\ob{\mathtt{Int}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{Int}}=\mathtt{Int}\)</li>
<li>\(∘=\mathtt{(+)}\)</li>
</ul>
<div class="flush"></div>
<ul><li>id: <code>length [] = 0</code>
</li><li>comp: <code>length (l ++ l') = (length l) + (length l')</code>
</li></ul>
</section>
<section class="slide">
<h2 id="category-of-endofunctors">Category of Endofunctors</h2>
<img src="categories/img/mp/natural-transformation.png" alt="Natural transformation commutative diagram" class="right"/>
<p>All endofunctors of \(\C\) form the category \(\E_\C\) of endofunctors of \(\C\).</p>
<ul>
<li>\(\ob{\E_\C}\): endofunctors of \(\C\) ; \(F:\C→\C\)</li>
<li>\(\hom{\E_\C}\): natural transformations
<ul>
<li>η familly \(η_X\in\hom{\C}\) for \(X\in\ob{\C}\) s.t.</li>
<li>ex: for Haskell functors: <code>F a -&gt; G a</code> are the natural transformations.</li>
</ul></li>
</ul>
</section>
<section class="slide">
<h2 id="monads">Monads</h2>
<blockquote>
<p>A Monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>
<blockquote>
<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
</blockquote>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-14">Monads are just monoids (1/4)</h2>
<p>A monoid is a triplet \((E,∙,e)\) s.t.</p>
<ul>
<li>\(E\) a set</li>
<li>\(∙:E×E→E\)</li>
<li>\(e:1→E\)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(x∙(y∙z) = (x∙y)∙z, ∀x,y,z∈E\)</li>
<li>\(e∙x = x = x∙e, ∀x∈E\)</li>
</ul>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-24">Monads are just Monoids (2/4)</h2>
<p>A Monad is a triplet \((M,⊙,η)\) s.t.</p>
<ul>
<li>\(M\) an <span class="yellow">Endofunctor</span></li>
<li>\(⊙:M×M→M\) a nat. trans. (× is functor composition)</li>
<li>\(η:I→M\) a nat. trans. (\(I\) identity functor)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(M ⊙ (M ⊙ M)) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-34">Monads are just Monoids (3/4)</h2>
<p>Example: <code>Maybe</code> is a functor</p>
<ul>
<li>\(M\) an <span class="yellow">Endofunctor</span></li>
<li>\(⊙:M×M→M\) a nat. trans. (× is functor composition)</li>
<li>\(η:I→M\) a nat. trans. (\(I\) identity functor)</li>
</ul>
<pre class="haskell"><code>-- In Haskell ⊙ is "join" in "Control.Monad"
join :: Maybe (Maybe a) -> Maybe a
join (Just (Just x)) = Just x
join _               = Nothing

-- In Haskell the "return" function (unfortunate name)
η :: a -> Maybe a
η x = Just x</code></pre>


</section>
<section class="slide">
<h2 id="monads-are-just-monoids-44">Monads are just Monoids (4/4)</h2>
<p>Example: <code>Maybe</code> is a functor (<code>join</code> is ⊙)</p>
<ul>
<li>\(M ⊙ (M ⊙ M)) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
<pre class="nohighlight small"><code>join (Just (join (Just (Just x)))) = join (join (Just (Just (Just x))))
join (Just (join (Just Nothing))) = join (join (Just (Just Nothing)))
join (Just (join Nothing)) = join (join (Just Nothing))
join Nothing = join (join Nothing)

join (η (Just x)) =  Just x = Just (η x)
join (η  Nothing) = Nothing = Nothing</code></pre>

<p>And <code>(Maybe,join,η)</code> is a monad.</p>
</section>
<section class="slide">
<h2 id="monads-generalize-composition">Monads generalize composition</h2>
<p>Example with lists:</p>
<pre class="haskell"><code>f=\x->[x]        ⇒ f 1 = [1]    ⇒ (f.f) 1 = [[1]]
g=\x->[x+1]      ⇒ g 1 = [2]    ⇒ (g.g) 1 = ERROR [2]+1
h=\x->[x+1,x*10] ⇒ h 1 = [2,10] ⇒ (h.h) 1 = ERROR [2,10]+1</code></pre>

<p>How to fix that? Kleisli composition</p>
<p><code>f &lt;=&lt; g = \x -&gt; join ((fmap f) (g x))</code></p>
<pre class="haskell"><code>f=\x->[x]        ⇒ f 1 = [1]    ⇒ (f <=< f) 1 = [1]
g=\x->[x+1]      ⇒ g 1 = [2]    ⇒ (g <=< g) 1 = [3]
h=\x->[x+1,x*10] ⇒ h 1 = [2,10] ⇒ (h <=< h) 1 = [3,20,11,100]</code></pre>


</section>
<section class="slide">
<h2 id="monads-utility">Monads utility</h2>
<p>A monad can also hide computation details (ex: a common parameter).</p>
<p><code>DrawScene</code> to <code><span class="yellow">State Screen</span> DrawScene</code> ; still <b>pure</b>.</p>
<pre class="haskell left small" style="width:40%"><code>main = drawImage (width,height)

drawImage :: Screen -&gt; DrawScene
drawImage <span class="orange">screen</span> =
    drawPoint p <span class="orange">screen</span>
    drawCircle c <span class="orange">screen</span>
    drawRectangle r <span class="orange">screen</span>

drawPoint point <span class="orange">screen</span> = ...
drawCircle circle <span class="orange">screen</span> = ...
drawRectangle rectangle <span class="orange">screen</span> = ...</code></pre>
<pre class="haskell right small" style="width:45%"><code>main = do
    <span class="orange">put (Screen 1024 768)</span>
    drawImage

drawImage :: State Screen DrawScene
drawImage = do
    drawPoint p
    drawCircle c
    drawRectangle r

drawPoint :: Point -&gt; State Screen DrawScene
drawPoint p = do
    <span class="orange">Screensize width height &lt;- get</span>
    ...</code></pre>
</section>
<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
<!-- Y theme -->
<script src="js/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="js/highlight/highlight.pack.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>
