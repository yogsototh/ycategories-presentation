<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>Category Theory for Programming</title>

	<!-- Required stylesheet -->
	<link rel="stylesheet" href="core/deck.core.css">

	<!-- Extension CSS files go here. Remove or add as needed. -->
	<link rel="stylesheet" href="extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="extensions/status/deck.status.css">
	<link rel="stylesheet" href="extensions/hash/deck.hash.css">
    <link rel="stylesheet" href="extensions/scale/deck.scale.css">

	<!-- Transition theme. More available in /themes/transition/ or create your own. -->

    <!-- <link rel="stylesheet" href="themes/transition/fade.css"> -->
	<!-- Style theme. More available in /themes/style/ or create your own. -->
    <!-- <link rel="stylesheet" href="themes/style/web-2.0.css"> -->
    <link rel="stylesheet" href="themes/style/y/main.css" />
    <link rel="stylesheet" href="themes/style/y/solarized.css" />
	<!-- Required Modernizr file -->
	<script src="modernizr.custom.js"></script>
    <script>
        function gofullscreen(){
            var body=document.getElementById('body');
            try {
                body.requestFullScreen();
            } catch(err) {
                try {
                    body.webkitRequestFullScreen();
                } catch(err) {
                    body.mozRequestFullScreen();
                }
            }
            return false;
        }
    </script>
</head>
<body id="body" class="deck-container">

<div style="display:none">
\(\newcommand{\F}{\mathbf{F}}\)
\(\newcommand{\E}{\mathbf{E}}\)
\(\newcommand{\C}{\mathcal{C}}\)
\(\newcommand{\D}{\mathcal{D}}\)
\(\newcommand{\id}{\mathrm{id}}\)
\(\newcommand{\ob}[1]{\mathrm{ob}(#1)}\)
\(\newcommand{\hom}[1]{\mathrm{hom}(#1)}\)
\(\newcommand{\Set}{\mathbf{Set}}\)
\(\newcommand{\Mon}{\mathbf{Mon}}\)
\(\newcommand{\Vec}{\mathbf{Vec}}\)
\(\newcommand{\Grp}{\mathbf{Grp}}\)
\(\newcommand{\Rng}{\mathbf{Rng}}\)
\(\newcommand{\ML}{\mathbf{ML}}\)
\(\newcommand{\Hask}{\mathbf{Hask}}\)
\(\newcommand{\Cat}{\mathbf{Cat}}\)
\(\newcommand{\fmap}{\mathtt{fmap}}\)
</div>

<!-- Begin slides. Just make elements with a class of slide. -->

<section class="slide">
<div style="text-align:center; position:absolute; top: 2em;">
<h1 style="position: relative;">Category Theory <span class="and">&amp;</span> Programming</h1>
<author><em class="base01">by</em> Yann Esposito</author>
<div style="font-size:.5em">
    <twitter>
        <a href="http://twitter.com/yogsototh">@yogsototh</a>,
     </twitter>
     <googleplus>
        <a href="https://plus.google.com/117858550730178181663">+yogsototh</a>
     </googleplus>
</div>
<div class="base01" style="font-size: .5em; font-weight: 400; font-variant:italic">
    <div class="button" style="margin: .5em auto;border: solid 2px; padding: 5px; width: 8em"  onclick="javascript:gofullscreen();">ENTER FULLSCREEN</div>
    HTML presentation: use arrows, space to navigate.
</div>
</div>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li><span class="yellow">General overview</li>
    <li>Definitions</li>
    <li>Applications</li>
</ul>
</section>
<section class="slide">
<h2 id="general-overview">General Overview</h2>
<p>Recent Math Field ; 1942-45, Samuel Eilenberg <span class="and">&amp;</span> Saunders Mac Lane</p>
<p>Certainly one of the more abstract branches of math</p>
<ul>
<li>New math foundation<br /> formalism abstraction, package entire theory</li>
<li>Bridge between disciplines<br /> Physics, Quantum Physics, Topology, Logic, Computer Science</li>
</ul>
<p>From a Programmer perspective:</p>
<blockquote>
<p>Category Theory is a new language/framework for Math</p>
</blockquote>
</section>
<section class="slide">
<h2 id="math-programming-relation">Math Programming relation</h2>
<img class="right" src="categories/img/buddha.gif" alt="Buddha Fractal"/>
<p>Programming <em><span class="yellow">is</span></em> doing Math</p>
<p>Not convinced?<br />Certainly a <em>vocabulary</em> problem.</p>
<p>One of the goal of Category Theory is to create a <em>homogeneous vocabulary</em> between different disciplines.</p>
</section>
<section class="slide">
<h2 id="vocabulary">Vocabulary</h2>
<img class="right" src="categories/img/mindblown.gif" alt="mind blown"/>
<p>Math vocabulary used in this presentation:</p>
<blockquote>
<p>Category, Morphism, Associativity, Preorder, Functor, Endofunctor, Categorial property, Commutative diagram, Isomorph, Initial, Dual, Monoid Natural transformation, Monad, κατα-morphism,</p>
</blockquote>
<p>Most will be translated for the programmer.</p>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight: bold">
    <li>General overview</li>
    <li> <span class="yellow">Definitions</span>
<ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: 0 0 0 1em">
    <li>Category</li>
    <li>Intuition</li>
    <li>Examples</li>
    <li>Functor</li>
    <li>Examples</li>
</ul>
    </li>
    <li>Applications</li>
</ul>
</section>
<section class="slide">
<h2>Category</h2>

<p>A way of representing <strong><em>things</em></strong> and <strong><em>ways to go between things</em></strong>.</p>

<p> A Category \(\mathcal{C}\) is defined by:</p>
<ul>
    <li> <em>Objects (\(\ob{C}\))</em>,</li>
    <li> <em>Morphisms (\(\hom{C}\))</em>,</li>
    <li> a <em>Composition law (∘)</em></li>
    <li> obeying some <em>Properties</em>.</li>
</ul>
</section>
<section class="slide">
<h2>Category: Objects</h2>

<img src="categories/img/mp/objects.png" alt="objects" />

<p>\(\ob{\mathcal{C}}\) is a collection</p>
</section>
<section class="slide">
<h2>Category: Morphisms</h2>

<img src="categories/img/mp/morphisms.png" alt="morphisms"/>

<p>\(A\) and \(B\) objects of \(\C\)<br/>
\(\hom{A,B}\) is a collection of morphisms<br/>
\(f:A→B\) denote the fact \(f\) belongs to \(\hom{A,B}\)</p>
<p>\(\hom{\C}\) the collection of all morphisms of \(\C\)</p>
</section>
<section class="slide">
<h2>Category: Composition</h2>
<p>Composition (∘): associate to each couple \(f:A→B, g:B→C\)
    $$g∘f:A\rightarrow C$$
</p>
<img src="categories/img/mp/composition.png" alt="composition"/>
</section>
<section class="slide">
<h2>Category laws: neutral element</h2>
<p>for each object \(X\), there is an \(\id_X:X→X\),<br/>
such that for each \(f:A→B\):</p>
<img src="categories/img/mp/identity.png" alt="identity"/>
</section>
<section class="slide">
<h2>Category laws: Associativity</h2>
<p> Composition is associative:</p>
<img src="categories/img/mp/associativecomposition.png" alt="associative composition"/>
</section>
<section class="slide">
<h2>Commutative diagrams</h2>

<p>Two path with the same source and destination are equal.</p>
<figure class="left" style="max-width: 40%;margin-left: 10%;">
    <img
      src="categories/img/mp/commutative-diagram-assoc.png"
      alt="Commutative Diagram (Associativity)"/>
    <figcaption>
    \((h∘g)∘f = h∘(g∘f) \)
    </figcaption>
</figure>
<figure class="right" style="max-width:31%;margin-right: 10%;">
    <img
      src="categories/img/mp/commutative-diagram-id.png"
      alt="Commutative Diagram (Identity law)"/>
    <figcaption>
    \(id_B∘f = f = f∘id_A \)
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Can this be a category?</h2>
<p>\(\ob{\C},\hom{\C}\) fixed, is there a valid ∘?</p>
<figure class="left">
    <img src="categories/img/mp/cat-example1.png" alt="Category example 1"/>
    <figcaption class="slide">
        <span class="green">YES</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="categories/img/mp/cat-example2.png" alt="Category example 2"/>
    <figcaption class="slide">
        no candidate for \(g∘f\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="categories/img/mp/cat-example3.png" alt="Category example 3"/>
    <figcaption class="slide">
    <span class="green">YES</span>
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Can this be a category?</h2>
<figure class="left">
    <img src="categories/img/mp/cat-example4.png" alt="Category example 4"/>
    <figcaption class="slide">
        no candidate for \(f:C→B\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="right" style="min-width: 59%">
    <img src="categories/img/mp/cat-example5.png" alt="Category example 5"/>
    <figcaption class="slide">
    \((h∘g)∘f=\id_B∘f=f\)<br/>
    \(h∘(g∘f)=h∘\id_A=h\)<br/>
    but \(h≠f\)<br/>
    <span class="red">NO</span>
    </figcaption>
</figure>
</section>
<section class="slide">
<h2>Category \(\Set\)</h2>

<ul>
	<li> \(\ob{\Set}\) are <em>all</em> the sets</li>
    <li> \(\hom{E,F}\) are <em>all</em> functions from \(E\) to \(F\)</li>
    <li> ∘ is functions composition </li>
</ul>

<ul class="slide">
    <li>\(\ob{\Set}\) is a proper class ; not a set</li>
    <li>\(\hom{E,F}\) is a set</li>
	<li>\(\Set\) is then a <em>locally <b>small</b> category</em></li>
</ul>
</section>
<section class="slide">
<h2>Categories Everywhere?</h2>

<ul>
    <li>\(\Mon\): (monoids, monoid morphisms,∘)</li>
    <li>\(\Vec\): (Vectorial spaces, linear functions,∘)</li>
    <li>\(\Grp\): (groups, group morphisms,∘)</li>
    <li>\(\Rng\): (rings, ring morphisms,∘)</li>
    <li>Any deductive system <i>T</i>: (theorems, proofs, proof concatenation)</li>
    <li>\( \Hask\): (Haskell types, functions, <code>(.)</code> )</li>
    <li>...</li>
</ul>
</section>
<section class="slide">
<h2>Smaller Examples</h2>

<h3>Strings</h3>
<img class="right" style="max-width:17%" src="categories/img/mp/strings.png" alt="Monoids are one object categories"/>
<ul>
    <li> \(\ob{Str}\) is a singleton </li>
    <li> \(\hom{Str}\) each string </li>
    <li> ∘ is concatenation <code>(++)</code> </li>
</ul>
<ul>
    <li> <code>"" ++ u = u = u ++ ""</code> </li>
    <li> <code>(u ++ v) ++ w = u ++ (v ++ w)</code> </li>
</ul>
</section>
<section class="slide">
<h2>Finite Example?</h2>

<h3>Graph</h3>
<figure class="right" style="max-width:40%" >
<img src="categories/img/mp/graph-category.png" alt="Each graph is a category"/>
</figure>
<ul>
    <li> \(\ob{G}\) are vertices</li>
    <li> \(\hom{G}\) each path</li>
    <li> ∘ is path concatenation</li>
</ul>
<ul><li>\(\ob{G}=\{X,Y,Z\}\),
    </li><li>\(\hom{G}=\{ε,α,β,γ,αβ,βγ,...\}\)<br/>
    \(\phantom{\hom{G}}=(β?γ)?(αβγ)^*(αβ?)?\),
    </li><li>\(αβ∘γ=αβγ\)
</li></ul>
</section>
<section class="slide">
<h2>Degenerated Categories</h2>

<img class="right" style="max-width:17%" src="categories/img/mp/monoid.png" alt="Monoids are one object categories"/>
<h3>Monoids</h3>
<p>each Monoid \((M,e,⊙): \ob{M}=\{∙\},\hom{M}=M,\circ = ⊙\)</p>
<p>one object</p>
<p>Examples: <code>(Integer,0,+)</code>, <code>(Integer,1,*)</code>, <code>(Strings,"",++)</code>, <code>(Lists,[],++)</code>, ...
</section>
<section class="slide">
<h2>Number construction</h2>

<h3>Each Numbers as a whole category</h3>
<img src="categories/img/mp/numbers.png" alt="Each number as a category"/>
</section>
<section class="slide">
<h2>Degenerated Categories: Preorders</h2>

<h3>Preorders</h3>
<p>each preorder \((P,≤): \ob{P}={P},\hom{x,y}=\{{x≤y}\} ⇔ x≤y,f_{y,z} \circ f_{x,y} = f_{x,z} \)</p>
<em>At most one morphism between two objects.</em>
<img src="categories/img/mp/preorder.png" alt="preorder category"/>
</section>
<section class="slide">
<h2>Degenerated Categories</h2>

<img class="right" src="categories/img/mp/set.png" alt="Any set can be a category"/>
<h3>Any Set</h3>
<p>Any set \(E: \ob{E}=E, \hom{x,y}=\{x\} ⇔  x=y \)</p>
<p><em>Only identities ; not so interesting</em></p>
</section>
<section class="slide">
<h2>Categorical Property</h2>

<p>Any property which can be expressed in term of category, objects, morphism and composition</p>

<ul><li> <em>isomorphism</em>: \(f:A→B\) s.t. ∃g:B→A, \(g∘f=id_A\) <span class="and">&amp;</span> \(f∘g=id_B\)
</li><li> <em>Initial</em>: \(Z\in\ob{C}\) s.t. \(∀Y∈\ob{C}, \#\hom{Z,Y}=1\)
</li><li> <em>Dual</em>: reverse direction of arrows of \(\C\)
</li><li> <em>Functor</em>: structure preserving mapping between categories
</li><li> ...
</li></ul>
</section>
<section class="slide">
<h2>Functor</h2>

<p> A functor is a mapping between two categories.
Let \(\C\) and \(\D\) be two categories.
A <em>functor</em> <span class="yellow">\(\F\)</span> from \(\C\) to \(\D\):</p>
<ul>
    <li> Associate objects: \(A\in\ob{\C}\) to <span class="yellow">\(\F(A)\)</span>\( \in\ob{\D}\) </li>
    <li> Associate morphisms: \(f:A\to B\) to <span class="yellow">\(\F(f) : \F(A) \to \F(B)\)</span>
        such that
        <ul>
            <li>\( \F (\id_X) = \id_{\F(X)} \),</li>
            <li>\( \F (g \circ_\C f) = \F(g) \circ_\D \F(f) \)</li>
        </ul>
    </li>
</ul>
</section>
<section class="slide">
<h2>Functor Example (ob → ob)</h2>

<img src="categories/img/mp/functor.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Functor Example (hom → hom)</h2>

<img src="categories/img/mp/functor-morphism.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Functor Example</h2>

<img src="categories/img/mp/functor-morphism-color.png" alt="Functor"/>
</section>
<section class="slide">
<h2>Endofunctors</h2>

<p>An <em>endofunctor</em> for \(\C\) is a functor \(F:\C→\C\).</p>
<img src="categories/img/mp/endofunctor.png" alt="Endofunctor"/>
</section>
<section class="slide">
<h2>Category of Categories</h2>

<p>Categories and functors form a category: \(\Cat\)</p>
<ul><li>\(\ob{\Cat}\) are categories
</li><li>\(\hom{\Cat}\) are functors
</li><li>∘ is functor composition
</li></ul>
</section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li>Why?</li>
    <li>What?</li>
    <li><span class="yellow">How?
        <ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: -2em 0 0 1em">
            <li>\(\Hask\) category
            </li><li> Functors
            </li><li> Monads
            </li><li> Arrows
            </li><li> κατα-morphisms
            </li></ul>
    </li>
</ul>
</section>
<section class="slide">
<h2>Hask</h2>

<p>Category \(\Hask\):</p>

<img class="right" style="max-width:30%" src="categories/img/mp/hask.png" alt="Haskell Category Representation"/>

<ul><li>
\(\ob{\Hask} = \) Haskell types
</li><li>
\(\hom{\Hask} = \) Haskell functions
</li><li>
∘ = <code>(.)</code> Haskell function composition
</li></ul>

<p>Forget glitches because of <code>undefined</code>.</p>
</section>
<section class="slide">
<h2 id="haskell-kinds">Haskell Kinds</h2>
<p>In Haskell some types can take type variable. Typically: <code>[a]</code>.</p>
<pre><code>data Tree a = Node a [Tree a]
data CTree a b = CNode a [b]</code></pre>
<p>Types have <em>kind</em>; The kind is to type what type is to function. Kind are the &quot;type&quot; for some types (so meta).</p>
<pre><code>Int, Char :: *
[], Maybe, Tree :: * -&gt; *
CTree :: * -&gt; * -&gt; *
[Int], Maybe Char, Tree [Int] :: *</code></pre>
</section>
<section class="slide">
<h2 id="haskell-types">Haskell Types</h2>
<p>We can make function that can work for <em>all</em> type parameter. Such function can only work with the <em>topology</em> induced by the type. We know such function won't work <em>on</em> the elements.</p>
<p>Sometimes, the type determine a lot about the function:</p>
<pre class="haskell"><code>fst :: (a,b) -> a -- Only one choice
snd :: (a,b) -> b -- Only one choice
f :: a -> [a]     -- Many choices
-- Possibilities: f x=[], or [x], or [x,x] or [x,...,x]

? :: [a] -> [a] -- Many choices
-- can only duplicate/remove/reorder elements
-- for example: the type of addOne isn't [a] -> [a]
addOne l = map (+1) l</code></pre>


</section>
<section class="slide">
<h2>Haskell Functor vs \(\Hask\) Functor</h2>

<p>Functor for Haskell language is a type <code>F :: * -> *</code> which belong to the type class <code>Functor</code>.<br/>
It must implement <code>fmap :: (a -> b) -> (F a -> F b)</code>.

<p><span style="visibility:hidden"><span class="and">&amp;</span></span> <code>F</code>: \(\ob{\Hask}→\ob{\Hask}\)<br/> <span class="and">&amp;</span> <code>fmap</code>: \(\hom{\Hask}→\hom{\Hask}\)

<p>The couple <code>(F,fmap)</code> is a functor in the categorical sense for \(\Hask\) if for any <code>x :: F a</code>:</p>
<ul><li><code>fmap id x = x</code>
</li><li><code>fmap (f.g) x= (fmap f . fmap g) x</code>
</li></ul>
</section>
<section class="slide">
<h2>Haskell Functors Example: Maybe</h2>

<pre class="haskell"><code>data Maybe a = Just a | Nothing
instance Functor Maybe where
    fmap :: (a -> b) -> (Maybe a -> Maybe b)
    fmap f (Just a) = f a
    fmap f Nothing = Nothing

fmap (+1) (Just 1) == 2
fmap (+1) Nothing  == Nothing
fmap head (Just [1,2,3]) == Just 1</code></pre>
</section>
<section class="slide">
<h2>Haskell Functors Example: List</h2>

<pre class="haskell"><code>
instance Functor ([]) where
    fmap :: (a -> b) -> [a] -> [b]
    fmap = map

fmap (+1) [1,2,3]           == [2,3,4]
fmap (+1) []                == []
fmap head [[1,2,3],[4,5,6]] == [1,4]
</code></pre>
</section>
<section class="slide">
<h2>String like type</h2>

<pre class="haskell"><code>
data F a = Cons Char a | Nil
-- examples :
--  Cons 'c' 32 :: F Int
--  Cons 'c' (\x -> x*x) :: F (Int -> Int)
--  Cons 'c' (Cons 'a' (\x -> x*x)) :: F (F (Int -> Int))
--  Cons 'c' (Cons 'c' Nil) :: F (F (F))
-- note String is the fixed point of F: F(F(F(...)))
instance Functor F where
    fmap :: (a -> b) -> [a] -> [b]
    fmap f (Cons c x) = Cons c (f x)
    fmap f Nil = Nil

fmap (+1) (Cons 'c' 3)      == Cons 'c' 4
fmap (+1) Nil               == Nil
fmap head (Cons 'c' [1,2,3])== Cons 'c' 1
</code></pre>
</section>
<section class="slide">
<h2>Haskell Functor intuition</h2>

<p>Put normal function inside a container. Ex: list, trees...<p>

<img src="categories/img/mp/boxfunctor.png" alt="Haskell Functor as a box play"/>
</section>
<section class="slide">
<h2>Haskell Functor properties</h2>

<p>Haskell Functors are:</p>

<ul><li><em>endofunctors</em> ; \(F:\C→\C\) here \(\C = \Hask\),
</li><li>a couple <b>(Object,Morphism)</b> in \(\Hask\).
</li></ul>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor-objects.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types is fractal:</p>

<img src="categories/img/mp/hask-endofunctor-morphisms.png" alt="Haskell functor representation"/>
</section>
<section class="slide">
<h2 id="non-haskell-hasks-functors">&quot;Non Haskell&quot; Hask's Functors</h2>
<p>A simple basic example is the \(id_\Hask\) functor. It simply cannot be expressed as a couple (<code>F</code>,<code>fmap</code>) where</p>
<ul>
<li><code>F::* -&gt; *</code></li>
<li><code>fmap :: (a -&gt; b) -&gt; (F a) -&gt; (F b)</code></li>
</ul>
<p>Another example:</p>
<ul>
<li>F(<code>T</code>)=<code>Int</code></li>
<li>F(<code>f</code>)=<code>\_-&gt;0</code></li>
</ul>
</section>
<section class="slide">
<h2 id="also-functor-inside-hask">Also Functor inside \(\Hask\)</h2>
<p><code>length</code> can be seen as a Functor from the category <code>[a]</code> to <code>Int</code>. More precisely:</p>
<ul class="left">
<li>\(\ob{\mathtt{[a]}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{[a]}}=\mathtt{[a]}\)</li>
<li>\(∘=\mathtt{(++)}\)</li>
</ul>
<p class="left" style="margin:2em 3em">⇒</p>
<ul class="left">
<li>\(\ob{\mathtt{Int}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{Int}}=\mathtt{Int}\)</li>
<li>\(∘=\mathtt{(+)}\)</li>
</ul>
<div class="flush"></div>
<ul><li>id: <code>length [] = 0</code>
</li><li>comp: <code>length (l ++ l') = (length l) + (length l')</code>
</li></ul>
</section>
<section class="slide">
<h2 id="category-of-endofunctors">Category of Endofunctors</h2>
<img src="categories/img/mp/natural-transformation.png" alt="Natural transformation commutative diagram" class="right"/>
<p>All endofunctors of \(\C\) form the category \(\E_\C\) of endofunctors of \(\C\).</p>
<ul>
<li>\(\ob{\E_\C}\): endofunctors of \(\C\) ; \(F:\C→\C\)</li>
<li>\(\hom{\E_\C}\): natural transformations
<ul>
<li>η familly \(η_X\in\hom{\C}\) for \(X\in\ob{\C}\) s.t.</li>
<li>ex: for Haskell functors: <code>F a -&gt; G a</code> are the natural transformations.</li>
</ul></li>
</ul>
</section>
<section class="slide">
<h2 id="monads">Monads</h2>
<blockquote>
<p>A Monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>
<blockquote>
<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
</blockquote>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-14">Monads are just monoids (1/4)</h2>
<p>A monoid is a triplet \((E,∙,e)\) s.t.</p>
<ul>
<li>\(E\) a set</li>
<li>\(∙:E×E→E\)</li>
<li>\(e:1→E\)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(x∙(y∙z) = (x∙y)∙z, ∀x,y,z∈E\)</li>
<li>\(e∙x = x = x∙e, ∀x∈E\)</li>
</ul>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-24">Monads are just Monoids (2/4)</h2>
<p>A Monad is a triplet \((M,⊙,η)\) s.t.</p>
<ul>
<li>\(M\) an <span class="yellow">Endofunctor</span></li>
<li>\(⊙:M×M→M\) a nat. trans. (× is functor composition)</li>
<li>\(η:I→M\) a nat. trans. (\(I\) identity functor)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(M ⊙ (M ⊙ M)) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
</section>
<section class="slide">
<h2 id="monads-are-just-monoids-34">Monads are just Monoids (3/4)</h2>
<p>Example: <code>Maybe</code> is a functor</p>
<ul>
<li>\(M\) an <span class="yellow">Endofunctor</span></li>
<li>\(⊙:M×M→M\) a nat. trans. (× is functor composition)</li>
<li>\(η:I→M\) a nat. trans. (\(I\) identity functor)</li>
</ul>
<pre class="haskell"><code>-- In Haskell ⊙ is "join" in "Control.Monad"
join :: Maybe (Maybe a) -> Maybe a
join (Just (Just x)) = Just x
join _               = Nothing

-- In Haskell the "return" function (unfortunate name)
η :: a -> Maybe a
η x = Just x</code></pre>


</section>
<section class="slide">
<h2 id="monads-are-just-monoids-44">Monads are just Monoids (4/4)</h2>
<p>Example: <code>Maybe</code> is a functor (<code>join</code> is ⊙)</p>
<ul>
<li>\(M ⊙ (M ⊙ M)) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
<pre class="nohighlight small"><code>join (Just (join (Just (Just x)))) = join (join (Just (Just (Just x))))
join (Just (join (Just Nothing))) = join (join (Just (Just Nothing)))
join (Just (join Nothing)) = join (join (Just Nothing))
join Nothing = join (join Nothing)

join (η (Just x)) =  Just x = Just (η x)
join (η  Nothing) = Nothing = Nothing</code></pre>

<p>And <code>(Maybe,join,η)</code> is a monad.</p>
</section>
<section class="slide">
<h2 id="monads-generalize-composition">Monads generalize composition</h2>
<p>Example with lists:</p>
<pre class="haskell"><code>f=\x->[x]        ⇒ f 1 = [1]    ⇒ (f.f) 1 = [[1]]
g=\x->[x+1]      ⇒ g 1 = [2]    ⇒ (g.g) 1 = ERROR [2]+1
h=\x->[x+1,x*10] ⇒ h 1 = [2,10] ⇒ (h.h) 1 = ERROR [2,10]+1</code></pre>

<p>How to fix that? Kleisli composition</p>
<p><code>f &lt;=&lt; g = \x -&gt; join ((fmap f) (g x))</code></p>
<pre class="haskell"><code>f=\x->[x]        ⇒ f 1 = [1]    ⇒ (f <=< f) 1 = [1]
g=\x->[x+1]      ⇒ g 1 = [2]    ⇒ (g <=< g) 1 = [3]
h=\x->[x+1,x*10] ⇒ h 1 = [2,10] ⇒ (h <=< h) 1 = [3,20,11,100]</code></pre>


</section>
<section class="slide">
<h2 id="monads-utility">Monads utility</h2>
<p>A monad can also hide computation details (ex: a common parameter).</p>
<p><code>DrawScene</code> to <code><span class="yellow">State Screen</span> DrawScene</code> ; still <b>pure</b>.</p>
<pre class="haskell left small" style="width:40%"><code>main = drawImage (width,height)

drawImage :: Screen -&gt; DrawScene
drawImage <span class="orange">screen</span> =
    drawPoint p <span class="orange">screen</span>
    drawCircle c <span class="orange">screen</span>
    drawRectangle r <span class="orange">screen</span>

drawPoint point <span class="orange">screen</span> = ...
drawCircle circle <span class="orange">screen</span> = ...
drawRectangle rectangle <span class="orange">screen</span> = ...</code></pre>
<pre class="haskell right small" style="width:45%"><code>main = do
    <span class="orange">put (Screen 1024 768)</span>
    drawImage

drawImage :: State Screen DrawScene
drawImage = do
    drawPoint p
    drawCircle c
    drawRectangle r

drawPoint :: Point -&gt; State Screen DrawScene
drawPoint p = do
    <span class="orange">Screensize width height &lt;- get</span>
    ...</code></pre>
</section>
<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
<!-- Y theme -->
<script src="js/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="js/highlight/highlight.pack.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>
