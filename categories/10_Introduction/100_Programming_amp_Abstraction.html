<h2>Programming <span class="and">&amp;</span> Abstraction</h2>

<h3>Polymorphism on <code>* -> *</code> types <code>(>>=)</code></h3>

<pre class="haskell"><code>data Maybe a = Just a | Nothing
(Just 1) >>= \x -> (Just 2) >>= \y -> Just (x+y) = Just 3
(Just 1) >>= \x ->  Nothing >>= \y -> Just (x+y) = Nothing
-- Lists [a]
[1,2] >>= (\x -> [10,20] >>= (\y -> return (x+y))) = [11,21,12,22]
[1,2] >>= (\x ->      [] >>= (\y -> return (x+y))) = []
-- More abstract
(Just 2) >>= \x -> (Just (\z->z*z)) >>= \f -> Just (f x) = Just 4
Just 2         :: Maybe Integer  -- in fact: Num a => Maybe a
Just (\z->z*z) :: Maybe (a -> a) -- in fact: Num a => Maybe (a -> a)
</code></pre>
